---
title: "8:54:08 PM - January 2, 2026"
date: 2026-01-03T01:54:08.600Z
timestamp: 1767405248600
---

## Project Notes

## Metadata Module Architecture Analysis

Completed exploration of both metadata modules:

### Sources Module (`src/pmd/sources/metadata/`)
**Purpose**: Load-time metadata extraction from documents

**Files**:
- `profiles.py`: Protocol + ExtractedMetadata dataclass (pure data models)
- `parsers.py`: YAML frontmatter + inline tag extraction (parsing utilities)
- `implementations.py`: GenericProfile, ObsidianProfile, DraftsProfile
- `registry.py`: Profile selection by path pattern or content detection

**Key Concepts**:
- ExtractedMetadata: tags (set), source_tags (list), attributes (dict), extraction_source (str)
- MetadataProfile protocol: extract_metadata() + normalize_tag()
- Three profiles handle different document sources (Obsidian nested/, Drafts hyphen-, Generic flat)
- Profiles normalize tags: lowercase, trim, handle hierarchy
- Registry auto-detects profiles or allows explicit selection

### Search Module (`src/pmd/search/metadata/`)
**Purpose**: Query-time tag inference + document retrieval/scoring

**Files**:
- `ontology.py`: Parent-child tag hierarchy for boosting
- `inference.py`: LexicalTagMatcher for query->tag inference
- `retrieval.py`: TagRetriever for tag-based document search
- `scoring.py`: apply_metadata_boost, apply_metadata_boost_v2
- `implementations/parsers/profiles/registry.py`: SHIMS importing from sources module

**Key Concepts**:
- Ontology: Hierarchical tag relationships (parent_weight=0.7)
  - expand_for_matching() expands query tags with ancestor weights
  - Example: "ml/supervised/regression" -> {ml/supervised/regression: 1.0, ml/supervised: 0.7, ml: 0.49}
- LexicalTagMatcher: Dictionary-based inference from queries
  - Exact matches (confidence 1.0)
  - Alias matches (confidence 0.9, from tag_aliases.json)
  - Prefix matches optional (confidence 0.7)
- TagRetriever: RRF-compatible retrieval by tags (with weighted scoring)
- apply_metadata_boost_v2: Weighted boosting using ontology expansion

### Shared Architecture
**Common Types** (currently duplicated across shims):
- ExtractedMetadata (sources) - used by both sides
- MetadataProfile protocol (sources) - extraction interface
- Parsers (sources) - shared by both
- ProfileRegistry (sources) - used by both

**Current Cross-References**:
- Search module imports from sources for profiles/parsers/registry via shims
- Pipeline.py imports: LexicalTagMatcher, Ontology, TagRetriever from search.metadata
- Pipeline uses tag_matcher for query inference + metadata_repo for document tags

### Ontology Hierarchy (tag_ontology.json)
Parent-child relationships with parent_weight: 0.7
Categories: programming, machine-learning, web, devops, data
Each has 2-3 levels of hierarchy
Example: programming -> languages/paradigms/patterns -> specific implementations

### Tag Aliases (tag_aliases.json)
Simple mapping of synonyms -> canonical tags
Examples: py->python, k8s->kubernetes, ml->machine-learning
No hierarchy in aliases, just 1:1 mappings

### Integration Pattern (pipeline.py)
```
Query -> LexicalTagMatcher.infer_tags() -> set[str]
       -> Ontology.expand_for_matching() -> dict[str, float] (weighted)
       -> apply_metadata_boost_v2() -> re-score results
       -> OR TagRetriever.search() -> retrieve by tags (RRF compatible)
```

### Key Insights
1. **Architectural Separation is Good**: Sources handles extraction (load-time), search handles inference/matching (query-time)
2. **Ontology is Search-Specific**: Tag hierarchy only needed for query boosting, not for extraction
3. **Shims Indicate Shared Code**: profiles/parsers/registry are extraction concepts, not search
4. **Inference System Sophisticated**: Two-stage tag matching (lexical + ontology)
5. **Weighted Scoring**: apply_metadata_boost_v2 is more sophisticated than v1
6. **Tag Storage is Generic**: DocumentMetadataRepository stores tags in junction table, no hierarchy knowledge

### Duplication Analysis
- Profiles/parsers/registry are properly isolated in sources
- Search correctly re-exports via shims
- Ontology is search-specific (good)
- LexicalTagMatcher is search-specific (good)
- No problematic duplication, just architectural layering

### What Should Be Unified
1. ExtractedMetadata - already shared (well-designed)
2. MetadataProfile protocol - already in sources (correct)
3. Parsing utilities - already in sources (correct)
4. Tag hierarchy concept - currently ONLY in ontology.json (read-only at query time, not used in extraction)

### What Should Stay Separate
1. Ontology - search/inference specific
2. LexicalTagMatcher - search/inference specific
3. TagRetriever - search retrieval specific
4. Boosting functions - search scoring specific
5. Extraction profiles - loading specific

The architecture is actually quite clean. The shims in search/metadata are just convenience imports for compatibility.

